<div role="tabpanel">
  <section class="card">
    <h2>NPC Dialogue Generator</h2>
    <div class="content">
      <p class="spacer10-bottom">Generate dialogue for a specific NPC. You can also enter a specific NPC ID.</p>
      <div class="field valign">
        <div class="valign grow" style="max-width:700px">
          <input class="dialogue-generate-input grow" type="text" placeholder="Enter the exact name of an NPC (case insensitive)" style="border-top-right-radius:0;border-bottom-right-radius:0;" />
          <button class="dialogue-generate-submit primary primary--2 spacer5-left">Generate</button>
        </div>
        <div class="dialogue-generate-submit-pending hide loading small spacer5-left"></div>
      </div>
      <hr class="spacer10-top spacer10-bottom">
      <ul style="font-size:14.5px;line-height:20px;">
        <li>If you can't find the dialogue you're looking for, try entering part of the first line of the dialogue (if you have it) into the "Single Branch Dialogue Generator" tool.</li>
        <li>It may not find results if the NPC is disguised as "???"</li>
        <li>Try the other tools if you can't find the dialogue you're looking for.</li>
        <li>You may get multiple NPC results with different IDs but the same name. This is generally the same "person" but in the different conditions/situations/quest states. In other cases, it might actually be different people with the same name &mdash; there's an "Iris" in Dragonspine and an "Iris" in Sumeru, for example.</li>
      </ul>
    </div>
  </section>
  <div id="dialogue-generate-result"></div>
</div>

<script nonce="<%= req.context.nonce %>">
waitForConstant('app', app => {
  function loadResultFromURL() {
    const url = new URL(window.location.href);
    const query = url.searchParams.get('q');
    if (query) {
      document.querySelector('.dialogue-generate-input').value = query;
      document.querySelector('.dialogue-generate-submit').click();
    }
  }

  const listeners = [
    {
        ev: 'readyAsync',
        fn: function() {
          waitForConstant('axios', () => {
            loadResultFromURL();
          })
        }
    },
    {
      el: 'window',
      ev: 'popstate', // user clicks browser back/forward buttons
      fn: function(event) {
        console.log('URL changed to', window.location.href);

        if (/\/npc-dialogue\/?$/i.test(window.location.href)) {
          document.querySelector('#dialogue-generate-result').innerHTML = '';
        }

        if (/\/npc-dialogue.*[?&]q=/i.test(window.location.href)) {
          loadResultFromURL();
        }
      }
    },
    {
      el: '.dialogue-generate-input',
      ev: 'enter',
      fn: function(event, target) {
        document.querySelector('.dialogue-generate-submit').click();
      }
    },
    {
      el: '.dialogue-generate-submit',
      ev: 'click',
      fn: function(event, target) {
        let inputEl = document.querySelector('.dialogue-generate-input');
        let loadingEl = document.querySelector('.dialogue-generate-submit-pending');
        let text = inputEl.value.trim();

        if (!text) {
          app.flashTippy(inputEl, {content: 'Enter something in first!', delay:[0,2000]});
          return;
        }

        loadingEl.classList.remove('hide');
        inputEl.disabled = true;
        target.disabled = true;

        const url = new URL(window.location.href);
        url.searchParams.set('q', text);
        window.history.pushState({}, null, url.href);

        app.endpoints.generateNpcDialogue(text, true).then(result => {
          if (typeof result === 'string') {
            document.querySelector('#dialogue-generate-result').innerHTML = result;
          } else if (typeof result === 'object' && result.error_description) {
            document.querySelector('#dialogue-generate-result').innerHTML = '<div class="card"><div class="content">'+esc(result.error_description)+'</div></div>';
          }
          autosize(document.querySelectorAll('textarea.autosize'));
          autosize(document.querySelectorAll('.dialogue-container textarea'));
        }).finally(() => {
          loadingEl.classList.add('hide');
          inputEl.disabled = false;
          target.disabled = false;
        });
      }
    },
  ];

  app.startListeners(listeners);
});
</script>